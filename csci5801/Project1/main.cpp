#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <filesystem>
#include <algorithm>
#include <unordered_map>

namespace fs = std::filesystem;


struct LogEntry {
    std::string generatedBy;
    std::string type;
    std::unordered_map<std::string, std::vector<std::string>> fields;
};

/**
 * @brief 
 * 
 * @param directory 
 * @return std::vector<std::string> 
 */
std::vector<std::string> listLogFiles(const std::string &directory)
{
    std::vector<std::string> logFiles; // stores all log files in a directory

    // loop through directory check if file extension is .log
    for (const auto &entry : fs::directory_iterator(directory))
    {
        if (fs::is_regular_file(entry) && entry.path().extension() == ".log")
        {
            logFiles.push_back(entry.path());
            std::cout << entry.path() << std::endl;
        }
    }

    return logFiles;
}

/**
 * @brief will parse a single file and put it into a logfile struct
 *
 * @param filePath path to the file
 * @return LogEntry the logfile struct
 */
LogEntry parseLogFile(const std::string& filePath) {
    LogEntry entry;
    std::ifstream inputFile(filePath);
    
    if (inputFile.is_open()) {
        std::string line;

        // Read Generated By
        std::getline(inputFile, entry.generatedBy, '\0');

        // Read Type
        std::getline(inputFile, entry.type, '\0');

        // first line will be titles
        std::getline(inputFile, line);
        std::getline(inputFile, line);

        std::istringstream stream(line);
        std::string token;
        std::vector<std::string> headers;
        // read headers
        while (std::getline(stream, token, ',')) {
            headers.push_back(token);
            entry.fields[token] = std::vector<std::string>();
        }
        //read lines
        for (size_t i = 0; std::getline(inputFile, token, ','); i++)
        {
            entry.fields[headers[i%headers.size()]].push_back(token);
        }

    }
    return entry;
}

void search(const std::vector<std::string>& files, const std::vector<std::string>& searchVals) {
    for (const auto& file : files) {
        LogEntry entry = parseLogFile(file);

        // Check if the entry matches the specified criteria
        if ((searchVals[0].empty() || entry.generatedBy == searchVals[0]) &&
            (searchVals[1].empty() || entry.type == searchVals[1]) &&
            (searchVals[2].empty() || std::find(entry.fields[searchVals[2]].begin(), entry.fields[searchVals[2]].end(), searchVals[4])
            != entry.fields[searchVals[2]].end())) {
            std::cout << "Found in file: " << file << std::endl;
        }
    }
}

std::vector<std::string> parseInput(const std::vector<std::string>& files, const std::vector<std::string>& additionalArgs) {
    if (additionalArgs.size() % 2 != 0) {
        std::cerr << "Usage: search [madeby <name>] [type <typeoflog>] [field <nameoffield> = <value>]" << std::endl;
        exit(1);
    }

    std::vector<std::string> searchVals(5);

    // Process optional search criteria
    for (size_t i = 0; i < additionalArgs.size(); i++) {
        const std::string& arg = additionalArgs[i];

        if (arg == "madeby") {
            i++;
            searchVals[0] = additionalArgs[i];
        } else if (arg == "type") {
            i++;
            searchVals[1] = additionalArgs[i];
        } else if (arg == "field") {
            searchVals[2] = additionalArgs[i+1];
            searchVals[3] = additionalArgs[i+2];
            searchVals[4] = additionalArgs[i+3];
            i+=3;
        } else {
            std::cerr << "Unknown search criteria: " << arg << std::endl;
            exit(1);
        }
    }
    return searchVals;
}

int main(int argc, char *argv[])
{
    // Check if the correct number of command-line arguments is provided
    if (argc < 3)
    {
        std::cerr << "Usage: " << argv[0] << " <directory> <command>" << std::endl;
        return 1; // Return an error code
    }

    // Extract command-line arguments
    std::string directory = argv[1];

    // set text to lowercase
    std::string command = argv[2];
    for (char &c : command)
    {
        c = std::tolower(static_cast<unsigned char>(c));
    }
    // all following commands
    std::vector<std::string> additionalArgs(argv + 3, argv + argc);
    // list of logfiles
    std::vector<std::string> files = listLogFiles(directory);

    // Decide which action to take based on the provided command
    if (command == "search")
    {
        std::vector<std::string> searchVals = parseInput(files, additionalArgs);
        search(files, searchVals);
    }
    else
    {
        std::cerr << "Invalid action. Use 'search' 'search terms'." << std::endl;
        return 1; // Return an error code
    }

    return 0; // Return success
}
